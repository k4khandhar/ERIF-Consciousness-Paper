<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>ERIF Agent World Simulation</title>
    <style>
        body { font-family: Arial, sans-serif; display: flex; flex-direction: column; align-items: center; background-color: #f0f0f0; }
        h1 { color: #333; }
        #simulation-container { display: flex; align-items: flex-start; }
        canvas { border: 2px solid #555; background-color: #000; }
        #controls { margin-left: 20px; padding: 10px; border: 1px solid #ccc; background-color: #fff; }
        button { font-size: 16px; padding: 10px; margin: 5px; cursor: pointer; width: 100px; }
        #plots-container { display: flex; margin-top: 20px; }
        .plot { margin: 10px; border: 1px solid #ccc; }
        #info { margin-top: 10px; font-size: 14px; }
    </style>
</head>
<body>
    <h1>ERIF Agent World Simulation</h1>
    <p>By Rohit Khandhar & AI Assistant</p>
    <div id="simulation-container">
        <canvas id="worldCanvas" width="500" height="500"></canvas>
        <div id="controls">
            <button id="setupBtn">Setup</button><br>
            <button id="goBtn">Go / Stop</button><br>
            <div id="info">
                <p><strong>Ticks:</strong> <span id="ticksDisplay">0</span></p>
                <p><strong>World State:</strong> <span id="worldStateDisplay">Stable</span></p>
                <hr>
                <p style="color:blue;"><strong>Standard Agents:</strong> <span id="standardPop">0</span></p>
                <p style="color:red;"><strong>High-T Agents:</strong> <span id="hightPop">0</span></p>
                <p style="color:green;"><strong>ERIF Agents:</strong> <span id="erifPop">0</span></p>
            </div>
        </div>
    </div>
    <div id="plots-container">
        <canvas id="popPlot" width="400" height="300" class="plot"></canvas>
        <canvas id="energyPlot" width="400" height="300" class="plot"></canvas>
    </div>

    <script>
        // --- Core Simulation Logic (NetLogo translated to JavaScript) ---
        const canvas = document.getElementById('worldCanvas');
        const ctx = canvas.getContext('2d');
        const popCanvas = document.getElementById('popPlot');
        const popCtx = popCanvas.getContext('2d');
        const energyCanvas = document.getElementById('energyPlot');
        const energyCtx = energyCanvas.getContext('2d');

        const worldSize = 50;
        const patchSize = canvas.width / worldSize;
        const initialPopulation = 33;
        
        let agents = [];
        let patches = [];
        let worldState = "Stable";
        let ticksSinceChange = 0;
        let ticks = 0;
        let simulationRunning = false;
        let animationFrameId;

        let popHistory = { standard: [], hight: [], erif: [] };
        let energyHistory = { standard: [], hight: [], erif: [] };

        class Agent {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.energy = 100;
                this.angle = Math.random() * 360;
                this.lastFoodLocation = null;
                this.performanceMemory = new Array(10).fill(0);
                this.strategy = "Explore";
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x * patchSize + patchSize / 2, this.y * patchSize + patchSize / 2, patchSize / 2.5, 0, 2 * Math.PI);
                ctx.fillStyle = this.getColor();
                if (this.type === 'erif' && this.strategy === 'Exploit') {
                    ctx.strokeStyle = 'yellow';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                }
                ctx.fill();
            }

            getColor() {
                if (this.type === 'standard') return 'blue';
                if (this.type === 'hight') return 'red';
                if (this.type === 'erif') return 'green';
            }

            move() {
                if (this.type === 'erif') this.erifChooseStrategy();
                
                let strategyToUse = this.type === 'standard' ? 'Explore' : 
                                    this.type === 'hight' ? 'Exploit' : 
                                    this.strategy;

                if (strategyToUse === 'Explore' || (strategyToUse === 'Exploit' && !this.lastFoodLocation)) {
                    this.angle += (Math.random() - 0.5) * 50;
                } else if (strategyToUse === 'Exploit' && this.lastFoodLocation) {
                    const targetAngle = Math.atan2(this.lastFoodLocation.y - this.y, this.lastFoodLocation.x - this.x) * 180 / Math.PI;
                    this.angle = targetAngle;
                }
                
                this.x += Math.cos(this.angle * Math.PI / 180);
                this.y += Math.sin(this.angle * Math.PI / 180);

                // World wrap
                if (this.x < 0) this.x = worldSize - 1;
                if (this.x >= worldSize) this.x = 0;
                if (this.y < 0) this.y = worldSize - 1;
                if (this.y >= worldSize) this.y = 0;
            }

            erifChooseStrategy() {
                const recentPerformance = this.performanceMemory.reduce((a, b) => a + b, 0);
                this.strategy = (recentPerformance > 5) ? "Exploit" : "Explore";
                this.performanceMemory.push(0);
                this.performanceMemory.shift();
            }

            update() {
                this.move();
                this.energy -= 1;
                this.checkPatch();
            }

            checkPatch() {
                const patch = patches[Math.floor(this.y)][Math.floor(this.x)];
                if (patch.foodEnergy > 0) {
                    this.energy += patch.foodEnergy;
                    if (this.type === 'erif') {
                        this.performanceMemory[this.performanceMemory.length - 1] = patch.foodEnergy;
                    }
                    if (this.type === 'hight' || this.type === 'erif') {
                        this.lastFoodLocation = {x: Math.floor(this.x), y: Math.floor(this.y)};
                    }
                    patch.foodEnergy = 0;
                    patch.regrowthCounter = 50;
                }
                if (patch.isDanger) {
                    this.energy -= 50;
                    patch.isDanger = false;
                }
            }
        }

        function setup() {
            ticks = 0;
            ticksSinceChange = 0;
            worldState = "Stable";
            simulationRunning = false;
            cancelAnimationFrame(animationFrameId);

            // Setup patches
            patches = [];
            for (let i = 0; i < worldSize; i++) {
                patches[i] = [];
                for (let j = 0; j < worldSize; j++) {
                    patches[i][j] = { foodEnergy: 0, isDanger: false, regrowthCounter: 0 };
                }
            }
            sproutFood();
            sproutDanger();

            // Setup agents
            agents = [];
            for (let i = 0; i < initialPopulation; i++) {
                agents.push(new Agent(Math.random() * worldSize, Math.random() * worldSize, 'standard'));
                agents.push(new Agent(Math.random() * worldSize, Math.random() * worldSize, 'hight'));
                agents.push(new Agent(Math.random() * worldSize, Math.random() * worldSize, 'erif'));
            }

            popHistory = { standard: [], hight: [], erif: [] };
            energyHistory = { standard: [], hight: [], erif: [] };
            
            drawWorld();
            drawPlots();
            updateInfo();
        }

        function go() {
            if (!simulationRunning) return;
            
            agents.forEach(agent => agent.update());
            agents = agents.filter(agent => agent.energy > 0);

            patches.forEach(row => row.forEach(patch => {
                if (patch.regrowthCounter > 0) {
                    patch.regrowthCounter--;
                    if (patch.regrowthCounter === 0) {
                        patch.foodEnergy = 10;
                    }
                }
            }));
            
            ticks++;
            ticksSinceChange++;
            if (ticksSinceChange > 500) {
                ticksSinceChange = 0;
                worldState = (worldState === "Stable") ? "Chaotic" : "Stable";
                sproutFood();
                sproutDanger();
            }

            if (ticks % 10 === 0) { // Update plots every 10 ticks
                updateHistory();
                drawPlots();
            }
            
            drawWorld();
            updateInfo();
            
            if (agents.length === 0) {
                simulationRunning = false;
                document.getElementById('goBtn').textContent = 'Go';
            } else {
                animationFrameId = requestAnimationFrame(go);
            }
        }
        
        function sproutFood() {
            patches.forEach(row => row.forEach(patch => { if (patch.foodEnergy > 0) patch.foodEnergy = 0; }));
            const numFood = (worldState === "Stable") ? 50 : 20;
            for (let i = 0; i < numFood; i++) {
                const x = Math.floor(Math.random() * worldSize);
                const y = Math.floor(Math.random() * worldSize);
                patches[y][x].foodEnergy = 10;
            }
        }
        
        function sproutDanger() {
            patches.forEach(row => row.forEach(patch => { if (patch.isDanger) patch.isDanger = false; }));
            const numDanger = (worldState === "Stable") ? 5 : 20;
            for (let i = 0; i < numDanger; i++) {
                const x = Math.floor(Math.random() * worldSize);
                const y = Math.floor(Math.random() * worldSize);
                patches[y][x].isDanger = true;
            }
        }

        function drawWorld() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            // Draw patches
            for (let i = 0; i < worldSize; i++) {
                for (let j = 0; j < worldSize; j++) {
                    const patch = patches[i][j];
                    if (patch.foodEnergy > 0) ctx.fillStyle = 'darkgreen';
                    else if (patch.isDanger) ctx.fillStyle = 'orange';
                    else ctx.fillStyle = 'black';
                    ctx.fillRect(j * patchSize, i * patchSize, patchSize, patchSize);
                }
            }
            // Draw agents
            agents.forEach(agent => agent.draw());
        }

        function updateInfo() {
            document.getElementById('ticksDisplay').textContent = ticks;
            document.getElementById('worldStateDisplay').textContent = worldState;
            document.getElementById('standardPop').textContent = agents.filter(a=>a.type==='standard').length;
            document.getElementById('hightPop').textContent = agents.filter(a=>a.type==='hight').length;
            document.getElementById('erifPop').textContent = agents.filter(a=>a.type==='erif').length;
        }

        function updateHistory() {
            let standardPop = 0, hightPop = 0, erifPop = 0;
            let standardEnergy = 0, hightEnergy = 0, erifEnergy = 0;
            agents.forEach(a => {
                if (a.type === 'standard') { standardPop++; standardEnergy += a.energy; }
                if (a.type === 'hight') { hightPop++; hightEnergy += a.energy; }
                if (a.type === 'erif') { erifPop++; erifEnergy += a.energy; }
            });
            popHistory.standard.push(standardPop);
            popHistory.hight.push(hightPop);
            popHistory.erif.push(erifPop);
            energyHistory.standard.push(standardPop > 0 ? standardEnergy / standardPop : 0);
            energyHistory.hight.push(hightPop > 0 ? hightEnergy / hightPop : 0);
            energyHistory.erif.push(erifPop > 0 ? erifEnergy / erifPop : 0);
        }

        function drawPlots() {
            drawPlot(popCtx, popHistory, 'Populations');
            drawPlot(energyCtx, energyHistory, 'Average Energy');
        }

        function drawPlot(context, history, title) {
            context.clearRect(0, 0, context.canvas.width, context.canvas.height);
            context.fillStyle = '#fff';
            context.fillRect(0, 0, context.canvas.width, context.canvas.height);
            context.strokeStyle = '#ccc';
            context.strokeRect(0, 0, context.canvas.width, context.canvas.height);

            context.font = '14px Arial';
            context.fillStyle = 'black';
            context.textAlign = 'center';
            context.fillText(title, context.canvas.width / 2, 20);

            const colors = { standard: 'blue', hight: 'red', erif: 'green' };
            const maxVal = Math.max(1, ...Object.values(history).flat());

            for (const type in history) {
                context.beginPath();
                context.strokeStyle = colors[type];
                context.lineWidth = 2;
                history[type].forEach((val, i) => {
                    const x = (i / (popHistory.standard.length || 1)) * context.canvas.width;
                    const y = context.canvas.height - (val / maxVal) * (context.canvas.height - 30) - 10;
                    if (i === 0) context.moveTo(x, y);
                    else context.lineTo(x, y);
                });
                context.stroke();
            }
        }

        // --- Event Listeners ---
        document.getElementById('setupBtn').addEventListener('click', setup);
        document.getElementById('goBtn').addEventListener('click', () => {
            simulationRunning = !simulationRunning;
            document.getElementById('goBtn').textContent = simulationRunning ? 'Stop' : 'Go';
            if (simulationRunning) go();
        });

        // Initial setup
        setup();
    </script>
</body>
</html>